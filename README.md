# Mini Compiler – Syntax Analyzer

This repository contains selected parts of a **mini compiler project**, with a focus on the **syntax analyzer** component. The files and folders included here highlight the main functionalities of the parser, specifically:

* **Syntax Analysis** – Recursive descent parser that validates the program structure.
* **Symbol Table** – Tracks declared variables and their types.
* **Intermediate Code Generation** – Produces stack-based pseudo code for expressions and control flow.
* **Test Runner** – Example program to demonstrate parsing, error handling, and intermediate code output.

The purpose of the repository is to **showcase the core parsing features** rather than provide a production-ready compiler. The focus is on demonstrating how the **lexical analyzer** integrates with the parser and how the system translates raw program text into structured data and intermediate code.


## 📌 Project Overview

This project focuses on developing a **syntax analyzer** for a mini compiler written in Java.
The analyzer processes tokens generated by a **lexical analyzer** and applies **recursive descent parsing** to validate syntax, manage declarations, and build intermediate code.

The final result allows users to:

* Detect **syntax and semantic errors** in a simplified C-like language.
* Build a **symbol table** mapping identifiers to their declared types.
* Generate **intermediate pseudo code** for further compilation or interpretation.

Please note: The parser is designed to work with a private compiler package. Users without access to this package will not be able to run the project fully.

## ⚙️ Technologies Used

* **Java 11+** – Programming language used for implementation.
* **Custom Lexical Analyzer** – Token generator located in the `compiler` package.
* **Recursive Descent Parsing** – Parsing strategy used in `SyntaxAnalyzer.java`.
* **Stack-Based Intermediate Code** – Code generation model based on push/pop operations.


## 📊 Components & Features

The parser includes the following major features and modules:

### 1. Syntax Analysis

* Implements recursive descent parsing for program structure (`void main { ... }`).
* Supports variable declarations, assignments, arithmetic/logical expressions, control flow (`if`, `while`, `do-while`), and print statements.

### 2. Symbol Table

* Stores identifiers with their associated types (`int`, `float`, `boolean`).
* Detects duplicate declarations and undeclared identifier usage.

### 3. Intermediate Code Generation

* Produces stack-based instructions such as `push`, `lvalue`, `rvalue`, arithmetic operators, and conditional jumps.
* Generates labels for control structures (`if`, `else`, `while`, `do-while`).
* Ends programs with a `halt` instruction.

### 4. Error Handling

* Reports syntax and semantic errors with line numbers.
* Handles mismatched tokens, undeclared variables, and duplicate declarations.

### 5. Test Program

* `TestProgram.java` runs the compiler against a sample input file.
* Displays tokens, source program, symbol table, errors, and intermediate code.


## 👥 Transforming Code into Structured Output

This project demonstrates how raw program text is transformed into structured compiler data:

1. **Lexical Analyzer** – Breaks input into tokens.
2. **Syntax Analyzer** – Parses tokens, checks grammar, and enforces rules.
3. **Symbol Table** – Records declared variables and detects errors.
4. **Intermediate Code** – Generates stack-based instructions for further compilation stages.


## 🚀 Key Impact

* Transition from plain program text to **structured tokens, symbol table, and intermediate code**.
* Clear visualization of compiler phases for students of **compiler theory**.
* Demonstrates error handling, recursive parsing, and basic code generation.

## ⚠️ Important Note – Private Dependency

This project depends on the compiler package, which includes:
* LexicalAnalyzer – responsible for tokenizing the input program.
* Token – data structures used by the parser.
* Data types and supporting classes.

  Please note: The compiler package is private and cannot be shared publicly.
